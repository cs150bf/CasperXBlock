function fft_stage_1(FFTSize, FFTStage, input_bit_width, coeff_bit_width, downshift, add_latency, mult_latency, bram_latency, conv_latency, quantization, overflow, arch, opt_target, delays_bram, coeffs_bram, use_hdl, use_embedded, hardcode_shifts, dsp48_adders)
% This is a generated function based on subsystem:
%     single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1
% Though there are limitations about the generated script, 
% the main purpose of this utility is to make learning
% Sysgen Script easier.
% 
% To test it, run the following commands from MATLAB console:
% cfg.source = str2func('fft_stage_1');
% cfg.toplevel = 'single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1';
% args = {my_FFTSize, my_FFTStage, my_input_bit_width, my_coeff_bit_width, my_downshift, my_add_latency, my_mult_latency, my_bram_latency, my_conv_latency, my_quantization, my_overflow, my_arch, my_opt_target, my_delays_bram, my_coeffs_bram, my_use_hdl, my_use_embedded, my_hardcode_shifts, my_dsp48_adders};
% xBlock(cfg, args);
% 
% You can edit fft_stage_1.m to debug your script.
% 
% You can also replace the MaskInitialization code with the 
% following commands so the subsystem will be generated 
% according to the values of mask parameters.
% cfg.source = str2func('fft_stage_1');
% cfg.toplevel = gcb;
% args = {FFTSize, FFTStage, input_bit_width, coeff_bit_width, downshift, add_latency, mult_latency, bram_latency, conv_latency, quantization, overflow, arch, opt_target, delays_bram, coeffs_bram, use_hdl, use_embedded, hardcode_shifts, dsp48_adders};
% xBlock(cfg, args);
% 
% To configure the xBlock call in debug mode, in which mode,
% autolayout will be performed every time a block is added,
% run the following commands:
% cfg.source = str2func('fft_stage_1');
% cfg.toplevel = gcb;
% cfg.debug = 1;
% args = {FFTSize, FFTStage, input_bit_width, coeff_bit_width, downshift, add_latency, mult_latency, bram_latency, conv_latency, quantization, overflow, arch, opt_target, delays_bram, coeffs_bram, use_hdl, use_embedded, hardcode_shifts, dsp48_adders};
% xBlock(cfg, args);
% 
% To make the xBlock smart so it won't re-generate the
% subsystem if neither the arguments nor the scripts are
% changes, use as the following:
% cfg.source = str2func('fft_stage_1');
% cfg.toplevel = gcb;
% cfg.depend = {'fft_stage_1'};
% args = {FFTSize, FFTStage, input_bit_width, coeff_bit_width, downshift, add_latency, mult_latency, bram_latency, conv_latency, quantization, overflow, arch, opt_target, delays_bram, coeffs_bram, use_hdl, use_embedded, hardcode_shifts, dsp48_adders};
% xBlock(cfg, args);
% 
% See also xBlock, xInport, xOutport, xSignal, xlsub2script.


%% inports
xlsub5_in1 = xInport('in1');
xlsub5_in2 = xInport('in2');
xlsub5_of_in = xInport('of_in');
xlsub5_sync = xInport('sync');
xlsub5_shift = xInport('shift');

%% outports
xlsub5_out1 = xOutport('out1');
xlsub5_out2 = xOutport('out2');
xlsub5_of = xOutport('of');
xlsub5_sync_out = xOutport('sync_out');

%% diagram

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/Counter
xlsub5_Counter_out1 = xSignal;
xlsub5_Counter = xBlock(struct('source', 'Counter', 'name', 'Counter'), ...
                        struct('n_bits', FFTSize-FFTStage+1, ...
                               'rst', 'on', ...
                               'explicit_period', 'off', ...
                               'use_rpm', 'off'), ...
                        {xlsub5_sync}, ...
                        {xlsub5_Counter_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/Delay
xlsub5_Delay_out1 = xSignal;
xlsub5_Delay = xBlock(struct('source', 'Delay', 'name', 'Delay'), ...
                      [], ...
                      {xlsub5_sync}, ...
                      {xlsub5_Delay_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/Logical1
xlsub5_butterfly_direct_out3 = xSignal;
xlsub5_Logical1 = xBlock(struct('source', 'Logical', 'name', 'Logical1'), ...
                         struct('logical_function', 'OR', ...
                                'latency', 1, ...
                                'n_bits', 8, ...
                                'bin_pt', 2), ...
                         {xlsub5_butterfly_direct_out3, xlsub5_of_in}, ...
                         {xlsub5_of});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/Mux
xlsub5_Slice1_out1 = xSignal;
xlsub5_delay_f_out1 = xSignal;
xlsub5_Mux_out1 = xSignal;
xlsub5_Mux = xBlock(struct('source', 'Mux', 'name', 'Mux'), ...
                    struct('latency', 1, ...
                           'arith_type', 'Signed  (2''s comp)', ...
                           'n_bits', 8, ...
                           'bin_pt', 2), ...
                    {xlsub5_Slice1_out1, xlsub5_delay_f_out1, xlsub5_in1}, ...
                    {xlsub5_Mux_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/Mux1
xlsub5_Mux1_out1 = xSignal;
xlsub5_Mux1 = xBlock(struct('source', 'Mux', 'name', 'Mux1'), ...
                     struct('latency', 1, ...
                            'arith_type', 'Signed  (2''s comp)', ...
                            'n_bits', 8, ...
                            'bin_pt', 2), ...
                     {xlsub5_Slice1_out1, xlsub5_in1, xlsub5_delay_f_out1}, ...
                     {xlsub5_Mux1_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/Slice
xlsub5_Slice_out1 = xSignal;
xlsub5_Slice = xBlock(struct('source', 'Slice', 'name', 'Slice'), ...
                      struct('boolean_output', 'on', ...
                             'mode', 'Lower Bit Location + Width', ...
                             'bit1', -(FFTStage - 1), ...
                             'bit0', FFTStage - 1), ...
                      {xlsub5_shift}, ...
                      {xlsub5_Slice_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/Slice1
xlsub5_Slice1 = xBlock(struct('source', 'Slice', 'name', 'Slice1'), ...
                       [], ...
                       {xlsub5_Counter_out1}, ...
                       {xlsub5_Slice1_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/sync_delay
xlsub5_sync_delay_out1 = xSignal;
xlsub5_sync_delay = xBlock(struct('source', 'casper_library_delays/sync_delay', 'name', 'sync_delay'), ...
                           struct('DelayLen', 2^(FFTSize - FFTStage)), ...
                           {xlsub5_Delay_out1}, ...
                           {xlsub5_sync_delay_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/butterfly_direct
xlsub5_delay_b_out1 = xSignal;
xlsub5_butterfly_direct_sub = xBlock(struct('source', str2func('butterfly_direct'), 'name', 'butterfly_direct'), ...
                                 {'on', 8, 0, 7, 18, 18, 'on', 2, 3, 2, 1, 'Truncate', 'Wrap', 'Virtex5', 'logic', 'off', 'off', 'on', 'on', 'on'}, ...
                                 {xlsub5_delay_b_out1, xlsub5_Mux_out1, xlsub5_sync_delay_out1, xlsub5_Slice_out1}, ...
                                 {xlsub5_out1, xlsub5_out2, xlsub5_butterfly_direct_out3, xlsub5_sync_out});


if (strcmp(delays_bram, 'on')),
	delaytype='delay_bram';
else
	delaytype='delay_slr';
end
% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/delay_b
xlsub5_delay_b_sub = xBlock(struct('source',str2func('delay_general'), 'name', 'delay_b'), ...
							struct('delaytype', delaytype, ...
								   'DelayLen', 2^(FFTSize-FFTStage), ...
								   'bram_latency', bram_latency, ...
								   'use_dsp48', 'off'), ...
							{xlsub5_Mux1_out1}, ...
							{xlsub5_delay_b_out1});

% block: single_pol_xblock_tb/fft_wideband_real1/fft_biplex_real_4x0/biplex_core/fft_stage_1/delay_f
xlsub5_delay_f_sub = xBlock(struct('source',str2func('delay_general'), 'name', 'delay_f'), ...
							struct('delaytype', delaytype, ...
								   'DelayLen', 2^(FFTSize-FFTStage), ...
								   'bram_latency', bram_latency, ...
								   'use_dsp48', 'off'), ...
							{xlsub5_in2}, ...
							{xlsub5_delay_f_out1});



end


