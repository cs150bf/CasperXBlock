function twiddle_general_4mult(Coeffs, StepPeriod, coeffs_bram, coeff_bit_width, input_bit_width, add_latency, mult_latency, bram_latency, conv_latency, arch, use_hdl, use_embedded, quantization, overflow)
% This is a generated function based on subsystem:
%     twiddles_collections/twiddle_general_4mult
% Though there are limitations about the generated script, 
% the main purpose of this utility is to make learning
% Sysgen Script easier.
% 
% To test it, run the following commands from MATLAB console:
% cfg.source = str2func('twiddle_general_4mult');
% cfg.toplevel = 'twiddles_collections/twiddle_general_4mult';
% args = {my_Coeffs, my_StepPeriod, my_coeffs_bram, my_coeff_bit_width, my_input_bit_width, my_add_latency, my_mult_latency, my_bram_latency, my_conv_latency, my_arch, my_use_hdl, my_use_embedded, my_quantization, my_overflow};
% xBlock(cfg, args);
% 
% You can edit twiddle_general_4mult.m to debug your script.
% 
% You can also replace the MaskInitialization code with the 
% following commands so the subsystem will be generated 
% according to the values of mask parameters.
% cfg.source = str2func('twiddle_general_4mult');
% cfg.toplevel = gcb;
% args = {Coeffs, StepPeriod, coeffs_bram, coeff_bit_width, input_bit_width, add_latency, mult_latency, bram_latency, conv_latency, arch, use_hdl, use_embedded, quantization, overflow};
% xBlock(cfg, args);
% 
% To configure the xBlock call in debug mode, in which mode,
% autolayout will be performed every time a block is added,
% run the following commands:
% cfg.source = str2func('twiddle_general_4mult');
% cfg.toplevel = gcb;
% cfg.debug = 1;
% args = {Coeffs, StepPeriod, coeffs_bram, coeff_bit_width, input_bit_width, add_latency, mult_latency, bram_latency, conv_latency, arch, use_hdl, use_embedded, quantization, overflow};
% xBlock(cfg, args);
% 
% To make the xBlock smart so it won't re-generate the
% subsystem if neither the arguments nor the scripts are
% changes, use as the following:
% cfg.source = str2func('twiddle_general_4mult');
% cfg.toplevel = gcb;
% cfg.depend = {'twiddle_general_4mult'};
% args = {Coeffs, StepPeriod, coeffs_bram, coeff_bit_width, input_bit_width, add_latency, mult_latency, bram_latency, conv_latency, arch, use_hdl, use_embedded, quantization, overflow};
% xBlock(cfg, args);
% 
% See also xBlock, xInport, xOutport, xSignal, xlsub2script.


%% inports
xlsub2_a = xInport('a');
xlsub2_b = xInport('b');
xlsub2_sync = xInport('sync');

%% outports
xlsub2_a_re = xOutport('a_re');
xlsub2_a_im = xOutport('a_im');
xlsub2_bw_re = xOutport('bw_re');
xlsub2_bw_im = xOutport('bw_im');
xlsub2_sync_out = xOutport('sync_out');

%% diagram

% block: twiddles_collections/twiddle_general_4mult/AddSub
xlsub2_mult_out1 = xSignal;
xlsub2_mult2_out1 = xSignal;
xlsub2_AddSub_out1 = xSignal;
xlsub2_AddSub = xBlock(struct('source', 'AddSub', 'name', 'AddSub'), ...
                       struct('mode', 'Subtraction', ...
                              'latency', add_latency, ...
                              'use_behavioral_HDL', 'on'), ...
                       {xlsub2_mult_out1, xlsub2_mult2_out1}, ...
                       {xlsub2_AddSub_out1});

% block: twiddles_collections/twiddle_general_4mult/AddSub1
xlsub2_mult1_out1 = xSignal;
xlsub2_mult3_out1 = xSignal;
xlsub2_AddSub1_out1 = xSignal;
xlsub2_AddSub1 = xBlock(struct('source', 'AddSub', 'name', 'AddSub1'), ...
                        struct('latency', add_latency, ...
                               'use_behavioral_HDL', 'on'), ...
                        {xlsub2_mult1_out1, xlsub2_mult3_out1}, ...
                        {xlsub2_AddSub1_out1});

% block: twiddles_collections/twiddle_general_4mult/c_to_ri1
xlsub2_delay0_out1 = xSignal;
xlsub2_c_to_ri1 = xBlock(struct('source', 'casper_library_misc/c_to_ri', 'name', 'c_to_ri1'), ...
                         struct('n_bits', input_bit_width, ...
                                'bin_pt', input_bit_width-1), ...
                         {xlsub2_delay0_out1}, ...
                         {xlsub2_a_re, xlsub2_a_im});

% block: twiddles_collections/twiddle_general_4mult/c_to_ri2
xlsub2_coeff_gen_out1 = xSignal;
xlsub2_c_to_ri2_out1 = xSignal;
xlsub2_c_to_ri2_out2 = xSignal;
xlsub2_c_to_ri2 = xBlock(struct('source', 'casper_library_misc/c_to_ri', 'name', 'c_to_ri2'), ...
                         struct('n_bits', coeff_bit_width, ...
                                'bin_pt', coeff_bit_width-2), ...
                         {xlsub2_coeff_gen_out1}, ...
                         {xlsub2_c_to_ri2_out1, xlsub2_c_to_ri2_out2});

% block: twiddles_collections/twiddle_general_4mult/c_to_ri3
xlsub2_delay1_out1 = xSignal;
xlsub2_c_to_ri3_out1 = xSignal;
xlsub2_c_to_ri3_out2 = xSignal;
xlsub2_c_to_ri3 = xBlock(struct('source', 'casper_library_misc/c_to_ri', 'name', 'c_to_ri3'), ...
                         struct('n_bits', input_bit_width, ...
                                'bin_pt', input_bit_width-1), ...
                         {xlsub2_delay1_out1}, ...
                         {xlsub2_c_to_ri3_out1, xlsub2_c_to_ri3_out2});

% block: twiddles_collections/twiddle_general_4mult/convert0
xlsub2_convert0 = xBlock(struct('source', 'Convert', 'name', 'convert0'), ...
                         struct('n_bits', input_bit_width+4, ...
                                'bin_pt', input_bit_width+1, ...
                                'quantization', 'Round  (unbiased: +/- Inf)', ...
                                'latency', conv_latency, ...
                                'pipeline', 'on'), ...
                         {xlsub2_AddSub_out1}, ...
                         {xlsub2_bw_re});

% block: twiddles_collections/twiddle_general_4mult/convert1
xlsub2_convert1 = xBlock(struct('source', 'Convert', 'name', 'convert1'), ...
                         struct('n_bits', input_bit_width+4, ...
                                'bin_pt', input_bit_width+1, ...
                                'quantization', 'Round  (unbiased: +/- Inf)', ...
                                'latency', conv_latency, ...
                                'pipeline', 'on'), ...
                         {xlsub2_AddSub1_out1}, ...
                         {xlsub2_bw_im});

% block: twiddles_collections/twiddle_general_4mult/delay0
xlsub2_delay0 = xBlock(struct('source', 'Delay', 'name', 'delay0'), ...
                       struct('latency', mult_latency + add_latency + bram_latency + conv_latency), ...
                       {xlsub2_a}, ...
                       {xlsub2_delay0_out1});

% block: twiddles_collections/twiddle_general_4mult/delay1
xlsub2_delay1 = xBlock(struct('source', 'Delay', 'name', 'delay1'), ...
                       struct('latency', bram_latency, ...
                              'reg_retiming', 'on'), ...
                       {xlsub2_b}, ...
                       {xlsub2_delay1_out1});

% block: twiddles_collections/twiddle_general_4mult/delay2
xlsub2_delay2 = xBlock(struct('source', 'Delay', 'name', 'delay2'), ...
                       struct('latency', mult_latency + add_latency + bram_latency + conv_latency), ...
                       {xlsub2_sync}, ...
                       {xlsub2_sync_out});

% block: twiddles_collections/twiddle_general_4mult/mult
xlsub2_mult = xBlock(struct('source', 'Mult', 'name', 'mult'), ...
                     struct('latency', mult_latency, ...
                            'use_embedded', 'off'), ...
                     {xlsub2_c_to_ri3_out1, xlsub2_c_to_ri2_out1}, ...
                     {xlsub2_mult_out1});

% block: twiddles_collections/twiddle_general_4mult/mult1
xlsub2_mult1 = xBlock(struct('source', 'Mult', 'name', 'mult1'), ...
                      struct('latency', mult_latency, ...
                             'use_embedded', 'off'), ...
                      {xlsub2_c_to_ri3_out2, xlsub2_c_to_ri2_out1}, ...
                      {xlsub2_mult1_out1});

% block: twiddles_collections/twiddle_general_4mult/mult2
xlsub2_mult2 = xBlock(struct('source', 'Mult', 'name', 'mult2'), ...
                      struct('latency', mult_latency, ...
                             'use_embedded', 'off'), ...
                      {xlsub2_c_to_ri3_out2, xlsub2_c_to_ri2_out2}, ...
                      {xlsub2_mult2_out1});

% block: twiddles_collections/twiddle_general_4mult/mult3
xlsub2_mult3 = xBlock(struct('source', 'Mult', 'name', 'mult3'), ...
                      struct('latency', mult_latency, ...
                             'use_embedded', 'off'), ...
                      {xlsub2_c_to_ri3_out1, xlsub2_c_to_ri2_out2}, ...
                      {xlsub2_mult3_out1});

% block: twiddles_collections/twiddle_general_4mult/coeff_gen
xlsub2_coeff_gen_sub = xBlock(struct('source', @xlsub2_coeff_gen, 'name', 'coeff_gen'), ...
                          {[0+0i                                                                           0+1i], coeff_bit_width, 0, bram_latency, 'off'}, ...
                          {xlsub2_sync}, ...
                          {xlsub2_coeff_gen_out1});



function xlsub2_coeff_gen(Coeffs, coeff_bit_width, StepPeriod, bram_latency, coeffs_bram)


% Mask Initialization code



%% inports
xlsub3_rst = xInport('rst');

%% outports
xlsub3_w = xOutport('w');

%% diagram

% block: twiddles_collections/twiddle_general_4mult/coeff_gen/Counter
xlsub3_Counter_out1 = xSignal;
xlsub3_Counter = xBlock(struct('source', 'Counter', 'name', 'Counter'), ...
                        struct('n_bits', 1, ...
                               'rst', 'on'), ...
                        {xlsub3_rst}, ...
                        {xlsub3_Counter_out1});

% block: twiddles_collections/twiddle_general_4mult/coeff_gen/ROM
xlsub3_Slice_out1 = xSignal;
xlsub3_ROM_out1 = xSignal;
xlsub3_ROM = xBlock(struct('source', 'ROM', 'name', 'ROM'), ...
                    struct('depth', 2, ...
                           'initVector', [0                                      0], ...
                           'distributed_mem', 'Distributed memory', ...
                           'latency', 2, ...
                           'n_bits', 18, ...
                           'bin_pt', 16), ...
                    {xlsub3_Slice_out1}, ...
                    {xlsub3_ROM_out1});

% block: twiddles_collections/twiddle_general_4mult/coeff_gen/ROM1
xlsub3_ROM1_out1 = xSignal;
xlsub3_ROM1 = xBlock(struct('source', 'ROM', 'name', 'ROM1'), ...
                     struct('depth', 2, ...
                            'initVector', [0                                      1], ...
                            'distributed_mem', 'Distributed memory', ...
                            'latency', 2, ...
                            'n_bits', 18, ...
                            'bin_pt', 16), ...
                     {xlsub3_Slice_out1}, ...
                     {xlsub3_ROM1_out1});

% block: twiddles_collections/twiddle_general_4mult/coeff_gen/Slice
xlsub3_Slice = xBlock(struct('source', 'Slice', 'name', 'Slice'), ...
                      [], ...
                      {xlsub3_Counter_out1}, ...
                      {xlsub3_Slice_out1});

% block: twiddles_collections/twiddle_general_4mult/coeff_gen/ri_to_c
xlsub3_ri_to_c = xBlock(struct('source', 'casper_library_misc/ri_to_c', 'name', 'ri_to_c'), ...
                        [], ...
                        {xlsub3_ROM_out1, xlsub3_ROM1_out1}, ...
                        {xlsub3_w});



end

end

