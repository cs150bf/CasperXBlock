function fft_wideband_real_init_xblock(varargin)


% Set default vararg values.
defaults = { ...
    'FFTSize', 5, ...
    'n_inputs', 2, ...
    'input_bit_width', 18, ...
    'coeff_bit_width', 18,  ...
    'add_latency', 2, ...
    'mult_latency', 3, ...
    'bram_latency', 2, ...
    'conv_latency', 1, ...
    'input_latency', 0, ...
    'biplex_direct_latency', 0, ...
    'quantization', 'Round  (unbiased: +/- Inf)', ...
    'overflow', 'Saturate', ...
    'arch', 'Virtex5', ...
    'opt_target', 'logic', ...
    'coeffs_bit_limit', 8, ...
    'delays_bit_limit', 8, ...
    'specify_mult', 'on', ...
    'mult_spec', [1,1,1,1,1], ...
    'hardcode_shifts', 'off', ...
    'shift_schedule', [1 1 1 1 1], ...
    'dsp48_adders', 'on', ...
    'unscramble', 'on', ...
};

FFTSize = get_var('FFTSize', 'defaults', defaults, varargin{:});
n_inputs = get_var('n_inputs', 'defaults', defaults, varargin{:});
input_bit_width = get_var('input_bit_width', 'defaults', defaults, varargin{:});
coeff_bit_width = get_var('coeff_bit_width', 'defaults', defaults, varargin{:});
add_latency = get_var('add_latency', 'defaults', defaults, varargin{:})
mult_latency = get_var('mult_latency', 'defaults', defaults, varargin{:})
bram_latency = get_var('bram_latency', 'defaults', defaults, varargin{:})
conv_latency = get_var('conv_latency', 'defaults', defaults, varargin{:})
input_latency = get_var('input_latency', 'defaults', defaults, varargin{:});
biplex_direct_latency = get_var('biplex_direct_latency', 'defaults', defaults, varargin{:});
quantization = get_var('quantization', 'defaults', defaults, varargin{:});
overflow = get_var('overflow', 'defaults', defaults, varargin{:});
arch = get_var('arch', 'defaults', defaults, varargin{:});
opt_target = get_var('opt_target', 'defaults', defaults, varargin{:});
coeffs_bit_limit = get_var('coeffs_bit_limit', 'defaults', defaults, varargin{:});
delays_bit_limit = get_var('delays_bit_limit', 'defaults', defaults, varargin{:});
specify_mult = get_var('specify_mult', 'defaults', defaults, varargin{:});
mult_spec = get_var('mult_spec', 'defaults', defaults, varargin{:});
hardcode_shifts = get_var('hardcode_shifts', 'defaults', defaults, varargin{:});
shift_schedule = get_var('shift_schedule', 'defaults', defaults, varargin{:});
dsp48_adders = get_var('dsp48_adders', 'defaults', defaults, varargin{:});
unscramble = get_var('unscramble', 'defaults', defaults, varargin{:});

% split up multiplier specification
mults_biplex = 2.*ones(1, FFTSize-n_inputs);
mults_direct = 2.*ones(1, n_inputs);
if strcmp(specify_mult, 'on'),
    mults_biplex(1:FFTSize-n_inputs) = mult_spec(1: FFTSize-n_inputs);
    mults_direct = mult_spec(FFTSize-n_inputs+1:FFTSize);
end

% split up shift schedule
shifts_biplex = ones(1, FFTSize-n_inputs);
shifts_direct = ones(1, n_inputs);
if strcmp(hardcode_shifts, 'on'),
    shifts_biplex(1:FFTSize-n_inputs) = shift_schedule(1: FFTSize-n_inputs);
    shifts_direct = shift_schedule(FFTSize-n_inputs+1:FFTSize);
end


%% inports
sync = xInport('sync');
shift = xInport('shift');

direct_shift = xSignal;
% slice off shift bits for fft_direct
xBlock( struct('name', 'shift_slice', 'source', 'Slice'), ...
		struct('bit0', FFTSize-n_inputs, 'nbits', n_inputs ), {shift}, {direct_shift} );

if n_inputs < 2
	error('fft_wideband_real: Must have at least 2^2 inputs!')
end

n_biplexes = 2^(n_inputs-2);
data_inports = {};
biplex_of_outputs = {};

direct_sync_in = xSignal;
direct_inputs = {direct_sync_in, direct_shift};

for k = 1:n_biplexes
	% declare input ports
	in_ports = {};
	for m = 1:4
		in_ports{m} = xInport(['din_', num2str( 4*(k-1)+m-1 )]);
	end
	
	% declare output ports
	out0_k = xSignal;	
	out1_k = xSignal;
	out2_k = xSignal;
	out3_k = xSignal;			
	sync_out = xSignal;
	of = xSignal;
	
	sync_del = xSignal;

		
	% delay input ports & sync by 'input_latency'
	xBlock( struct('source', str2func('pipeline_init_xblock'), 'name', ['in_del_sync_4x', num2str(k-1)]), ...
			{input_latency}, {sync}, {sync_del} );

	biplex_in_ports = {sync_del, shift, xSignal, xSignal, xSignal, xSignal};
	for m = 1:4
		xBlock( struct('source', str2func('pipeline_init_xblock'), 'name', ['in_del_4x', num2str(k-1), 'pol', num2str(m)]), ...
				{input_latency}, {in_ports{m}}, {biplex_in_ports{m+2}} );		
	end
	

	biplex_sync_out = xSignal;
	biplex_pol1_out = xSignal;
	biplex_pol2_out = xSignal;
	biplex_pol3_out = xSignal;
	biplex_pol4_out = xSignal;
	biplex_of_out = xSignal;
	% instantiate biplex core in xBlock form
	xBlock( struct('source', str2func('fft_biplex_real_4x_init_xblock'), 'name', ['fft_biplex_real_4x', num2str(k-1)]), ...
			{ 'FFTSize', FFTSize-n_inputs, ...
			'input_bit_width', input_bit_width, ...
			'coeff_bit_width', coeff_bit_width, ...
			'add_latency', add_latency, ...
			'mult_latency', mult_latency, ...
			'bram_latency', bram_latency, ...
			'conv_latency', conv_latency, ...
			'quantization', quantization, ...
			'overflow', overflow, ...
			'arch', arch, ...
			'opt_target', opt_target, ...
			'coeffs_bit_limit', coeffs_bit_limit, ...
			'delays_bit_limit', delays_bit_limit, ...
			'specify_mult', specify_mult, ...
			'mult_spec', mults_biplex, ...
			'hardcode_shifts', hardcode_shifts, ...
			'shift_schedule', shifts_biplex, ...
			'dsp48_adders', dsp48_adders , ...
	        }, ...
	        biplex_in_ports, ...
	        {biplex_sync_out, biplex_pol1_out, biplex_pol2_out, biplex_pol3_out, biplex_pol4_out, biplex_of_out});
	
	biplex_of_outputs{k} = biplex_of_out;
	biplex_data_outputs = {biplex_pol1_out, biplex_pol2_out, biplex_pol3_out, biplex_pol4_out};
	biplex_data_outputs_del = {xSignal, xSignal, xSignal, xSignal};

	% TODO: delay the outports
	for m = 1:4
		xBlock( struct('source', str2func('pipeline_init_xblock'), 'name', ['out_del_4x', num2str(k-1), 'pol', num2str(m)]), ...
			{input_latency}, { biplex_data_outputs{m} }, { biplex_data_outputs_del{m} } );	
	end
	
	if k == 1
		xBlock( struct('source', str2func('pipeline_init_xblock'), 'name', ['out_del_sync_4x', num2str(k-1)]), ...
			{input_latency}, {biplex_sync_out}, {direct_sync_in} );
	end
	
	direct_inputs{4*k-3 + 2} = biplex_data_outputs_del{1};
	direct_inputs{4*k-2 + 2} = biplex_data_outputs_del{2};
	direct_inputs{4*k-1 + 2} = biplex_data_outputs_del{3};
	direct_inputs{4*k-0 + 2} = biplex_data_outputs_del{4};			
end


% Instantiate fft_direct block
direct_sync_out = xSignal;
direct_outports = {direct_sync_out};
for m = 1:2^(n_inputs)+1
	direct_outports{m+1} = xSignal;
end
   
xBlock( struct('name', 'fft_direct', 'source', str2func('fft_direct_init_xblock') ), ...
		{'FFTSize', n_inputs, ...
		'input_bit_width', input_bit_width, ...
		'coeff_bit_width', coeff_bit_width, ...
		'map_tail', 'on', ...
		'LargerFFTSize', (FFTSize), ...
		'StartStage', (FFTSize-n_inputs+1), ...
		'add_latency', (add_latency), ...
		'mult_latency', (mult_latency), ...
		'bram_latency', (bram_latency), ...
		'conv_latency', (conv_latency), ...
		'quantization', (quantization), ...
		'overflow', (overflow), ...
		'arch', (arch), ...
		'opt_target', (opt_target), ...
		'coeffs_bit_limit', (coeffs_bit_limit), ...
		'specify_mult', (specify_mult), ...
		'mult_spec', (mults_direct), ...
		'hardcode_shifts', (hardcode_shifts), ...
		'shift_schedule', (shifts_direct), ...
		'dsp48_adders', (dsp48_adders) }, ...
		direct_inputs, direct_outports );

%
% Add output unscrambler.
%

sync_out = xOutport('sync_out');
fft_outports = {sync_out};
for n = 1:2^(n_inputs-1)
	fft_outports{n+1} = xOutport(['dout', num2str(n-1)]);
end

if strcmp(unscramble, 'on'),
    xBlock( struct('name', 'fft_unscrambler', 'source', 'casper_library_ffts/fft_unscrambler'), ...
        {'FFTSize', FFTSize-1, 'n_inputs', n_inputs-1, 'bram_latency', bram_latency}, ...
        {direct_outports{1:1+2^(n_inputs-1)}}, fft_outports);
end

% generate output overflow 
of_outputs = { biplex_of_outputs{:}, direct_outports{end} };
of = xOutport('of');
xBlock(struct('source', 'Logical', 'name', 'of_det'), ...
				struct('logical_function', 'OR', 'inputs', n_biplexes+1), of_outputs, {of});


%% diagram

end

