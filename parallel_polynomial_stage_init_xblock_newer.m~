%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%   Center for Astronomy Signal Processing and Electronics Research           %
%   http://casper.berkeley.edu                                                %      
%   Copyright (C) 2011    Hong Chen                                           %
%                                                                             %
%   This program is free software; you can redistribute it and/or modify      %
%   it under the terms of the GNU General Public License as published by      %
%   the Free Software Foundation; either version 2 of the License, or         %
%   (at your option) any later version.                                       %
%                                                                             %
%   This program is distributed in the hope that it will be useful,           %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of            %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             %
%   GNU General Public License for more details.                              %
%                                                                             %
%   You should have received a copy of the GNU General Public License along   %
%   with this program; if not, write to the Free Software Foundation, Inc.,   %
%   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function parallel_polynomial_stage_init_xblock_newer(m,n_inputs,polyphase,add_latency,oddeven, n_bits, bin_pt)

coeffs = zeros(1,m+1);
for i = 1:m+1
    coeffs(1,i) = nchoosek(m,i-1);
end
 

if n_inputs==1 && strcmp(polyphase,'off') % only one input
    
    % non-polyphase structure
    inport = xInport('in');
    outport = xOutport('out');
    sync =xInport('sync');
    sync_out=xOutport('sync_out');
    
    polynomial_blk = xBlock(struct('source',str2func('polynomial_shift_mult_transpose_init_xblock'),'name','polynomial'), ...
                            {coeffs, add_latency,n_bits, bin_pt,'off'}, ...
                            {inport, sync}, ...
                            {outport, sync_out});


elseif n_inputs ==1 && strcmp(polyphase,'on')
    % polyphase structure
    inport = xInport('inport');
    outport = xOutport('outport');
    sync =xInport('sync');
    sync_out=xOutport('sync_out');
    
    first_delay_out = xSignal('delay1');
    first_delay = xBlock(struct('source','Delay','name', 'first_delay'), ...
                              struct('latency', 1), ...
                              {inport}, ...
                              {first_delay_out});
                          
                          
    ds_out0 =xSignal('downsample_out0');
    ds_out1 = xSignal('downsample_out1');
    downsampling0 = xBlock(struct('source', 'xbsBasic_r4/Down Sample', 'name', 'Down_sample0'), ...
                               struct('sample_ratio',2, ...
                                        'sample_phase','Last Value of Frame  (most efficient)', ...
                                      'latency', 1), ...
                          {inport}, ...
                          {ds_out0});  
    downsampling1 = xBlock(struct('source', 'xbsBasic_r4/Down Sample', 'name', 'Down_sample1'), ...
                               struct('sample_ratio',2, ...
                                        'sample_phase','Last Value of Frame  (most efficient)', ...
                                      'latency', 1), ...
                          {first_delay_out}, ...
                          {ds_out1}); 
                      
    poly_out0 = xSignal('poly_out0');
    poly_out1 = xSignal('poly_out1');
    sync_poly = xSignal('sync_poly');
    polynomial_blk0 = xBlock(struct('source',str2func('polynomial_shift_mult_transpose_init_xblock'),'name','polynomial0'), ...
                            {coeffs(1:2:end), add_latency,n_bits, bin_pt,'off'}, ...
                            {ds_out0, sync}, ...
                            {poly_out0, sync_poly});      
                        
    polynomial_blk1 = xBlock(struct('source',str2func('polynomial_shift_mult_transpose_init_xblock'),'name','polynomial1'), ...
                            {coeffs(2:2:end), add_latency,n_bits, bin_pt,'off'}, ...
                            {ds_out1, sync}, ...
                            {poly_out1,[]});                              

    final_adder = xBlock(struct('source','AddSub', 'name', 'final_adder'), ...
                             struct('mode', 'Addition', 'latency', add_latency, 'precision', 'Full', ...
                                    'use_behavioral_HDL', 'off', 'hw_selection', 'Fabric'), ...
                                    {poly_out0,poly_out1}, ...
                                    {outport});  
    % take care of sync
    sync_delay = xBlock(struct('source','Delay','name', 'sync_delay'), ...
                              struct('latency', add_latency + 1), ...   % compensate the downsample delay
                              {sync_poly}, ...
                              {sync_out});
elseif n_inputs ==2
    inport0  = xInport('in1');
    inport1 = xInport('in2');
    sync = xInport('sync');
    
    outport0 = xOutport('out0');
    outport1 = xOutport('out1');
    sync_out = xOutport('sync_out');    
    
    poly_out1_even = xSignal('poly_ou1_even');
    poly_out1_odd = xSignal('poly_out1_odd');
    poly_out0_odd = xSignal('poly_out0_odd');
    poly_out0_even = xSignal('poly_out0_even');
    sync_poly = xSignal('sync_poly');
    polynomial_blk0 = xBlock(struct('source',str2func('polynomial_shift_mult_transpose_init_xblock'),'name','polynomial0'), ...
                            {coeffs, add_latency,n_bits, bin_pt,'on'}, ...
                            {inport0, sync}, ...
                            {poly_out0_odd,poly_out0_even,sync_poly}); 
    polynomial_blk1= xBlock(struct('source',str2func('polynomial_shift_mult_transpose_init_xblock'),'name','polynomial1'), ...
                            {coeffs, add_latency,n_bits, bin_pt,'on'}, ...
                            {inport1, sync}, ...
                            {poly_out1_odd,poly_out1_even,[]}); 
                        
    d_poly_out1_even = xSignal('d_poly_out1_even');                 
    delay_1 = xBlock(struct('source','Delay','name', 'delay_1'), ...
                              struct('latency', 1), ...  
                              {poly_out1_even}, ...
                              {d_poly_out1_even});
                          
    final_adder1 = xBlock(struct('source','AddSub', 'name', 'final_adder1'), ...
                             struct('mode', 'Addition', 'latency', add_latency, 'precision', 'Full', ...
                                    'use_behavioral_HDL', 'off', 'hw_selection', 'Fabric'), ...
                                    {poly_out0_even,poly_out1_odd}, ...
                                    {outport1});  
    final_adder0 = xBlock(struct('source','AddSub', 'name', 'final_adder0'), ...
                             struct('mode', 'Addition', 'latency', add_latency, 'precision', 'Full', ...
                                    'use_behavioral_HDL', 'off', 'hw_selection', 'Fabric'), ...
                                    {poly_out0_odd,d_poly_out1_even}, ...
                                    {outport0});  
    % take care of sync
    sync_delay = xBlock(struct('source','Delay','name', 'sync_delay'), ...
                              struct('latency', add_latency ), ... 
                              {sync_poly}, ...
                              {sync_out});
                          
                          
elseif n_inputs >m  % think about this later
            
    inports = cell(1,n_inputs);
    for i = 1:n_inputs,
        inports{i} = xInport(['inport',num2str(i)]);
    end
    sync = xInport('sync');

    outports = cell(1,n_inputs);
    for i=1+mod(skip,2):2:n_inputs,
        outports{i} = xOutport(['outport',num2str(i)]);
    end
    sync_out = xOutport('sync_out');   
    
    
    
    % do the multiplications
    odd_coeffs = coeffs(1:2:end);
    odd_len = length(odd_coeffs);
    even_coeffs = coeffs(2:2:end);
    even_len = length(even_coeffs);
    mult_cxi_out = cell(1,n_inputs);
    mult_cxi_blks = cell(1,n_inputs);
    sync_mult = xSignal('sync_mult');
    for i =1:n_inputs
        if mod(i,2) == skip  % it means y_i(n) will be skipped, thus take the even coefficients
            mult_cxi_out{i} = cell(1,m+1);
            for j=2:2:m+1
                mult_cxi_out{i}{j} = xSignal(['mult_cxi_out',num2str(i),'_',num2str(j)]);
            end
            mult_cxi_blks{i} = xBlock(struct('source',str2func('shift_mult_array_init_xblock'), 'name', ['mult_cxi_blk',num2str(i)]), ...
                      {coeffs(2:2:end), add_latency, n_bits, bin_pt}, ...
                      {inports{i},sync}, ...
                      {mult_cxi_out{i}{2:2:end},[]}); 
        else
            mult_cxi_out{i} = cell(1,m+1);
            for j=1:2:m+1
                mult_cxi_out{i}{j} = xSignal(['mult_cxi_out',num2str(i),'_',num2str(j)]);
            end
            if i ==1
                mult_cxi_blks{i} = xBlock(struct('source',str2func('shift_mult_array_init_xblock'), 'name', ['mult_cxi_blk',num2str(i)]), ...
                          {coeffs(1:2:end), add_latency, n_bits, bin_pt}, ...
                          {inports{i},sync}, ...
                          {mult_cxi_out{i}{1:2:end},sync_mult});
            else
                mult_cxi_blks{i} = xBlock(struct('source',str2func('shift_mult_array_init_xblock'), 'name', ['mult_cxi_blk',num2str(i)]), ...
                          {coeffs(1:2:end), add_latency, n_bits, bin_pt}, ...
                          {inports{i},sync}, ...
                          {mult_cxi_out{i}{1:2:end},[]}); 
            end
        end
    end
    
    
    % add delays
    d_mult_cxi_out = cell{1,n_inputs};
    delay_blks = cell(1,m-1);
    for i = (n_inputs - m +1) : n_inputs
        d_mult_cxi_out{i} = cell(1,m+1);
        delay_blks = cell(1,m+1);
        k = i-(n_inputs - m +1);
        for j=m+1-k:(m+1)
            if mod(i,2) == skip   % coefficient take the even
                if mod(j,2) == 1 
                    continue;
                else
                    delay_blks{k+1}{j} = xBlock(struct('source','Delay','name', ['delay',num2str(k+1),'_',num2str(j)]), ...
                                                  struct('latency', add_latency), ...
                                                  {mult_cxi_out{i}{j}}, ...
                                                  {d_mult_cxi_out{i}{j}});

                end
            else  % coefficient take the odd
                if mod(j,2) == 0
                    continues
                else
                    delay_blks{k+1}{j} = xBlock(struct('source','Delay','name', ['delay',num2str(k+1),'_',num2str(j)]), ...
                                                  struct('latency', add_latency), ...
                                                  {mult_cxi_out{i}{j}}, ...
                                                  {d_mult_cxi_out{i}{j}});                    
                end
            end
        end
    end
        
    % organize the matrix
    mat = cell(n_inputs,m+1);
    ref_mat = zeros(n_inputs,m+1); % displayable, for debugging
    
    % top right triangle 
    % (correspond to the bottom right triangle in the
    % old matrix)
    for i = 1+mod(skip,2):2:m
        for j = 1+i:m+1
            k = j-(1+i);
            mat{i}{j} = d_mult_cxi_out{n_inputs-k}{j};
            ref_mat{i}{j} = [n_inputs-k,j];
        end
    end
    
    
    % middle parallelogram
    for i= 1+mod(skip,2):2:(n_inputs-m)
        for j = 1:m+1
            mat{i+j-1}{j} = mult_cxi_out{i}{j};
            ref_mat(i+j-1,j) = [i,j];
        end
    end
    
    
    % bottom triangle
    for i = (n_inputs - m+1):m
        if mod(i,2) == skip
            continue;
        else
            k = i - (n_inputs - m+1);
            for j = 1:(m-k)
                mat{i+j-1,j} = mult_cxi_out{i}{j};
                ref_mat(i+j-1,j) = [i,j];
            end
        end
    end

    % adder_trees for all the outputs
    adder_trees_blks = cell(1,n_inputs);
    for i= 1+mod(skip,2):2:(n_inputs-m)
        adder_trees_blks{i} = 
    end
end


% elseif n_inputs == 2
%         % polyphase structure
%     
%     inport1  = xInport('in1');
%     inport2 = xInport('in2');
%     sync = xInport('sync');
%     
%     outport = xOutport('out');
%     sync_out = xOutport('sync_out');
% 
%     if mod(m,2)==0
%         disp('don'' know what to do for now');
%         return
%     end
%     
%     
%     
%     delays1 = cell(1,int32(m./2)-1);
%     delays1_in = cell(1,int32(m./2));
%     delays2 = cell(1,int32(m./2)-1);
%     delays2_in = cell(1,int32(m./2));
%     delays1_in{1} = inport1;
%     delays2_in{1} = inport2;
%     for i = 1:(m/2)
%         delays1_in{i+1}=xSignal(['delays1_in',num2str(i+1)]);
%         delays1{i} = xBlock(struct('source', 'Delay', 'name', ['Delay1',num2str(i)]), ...
%                           struct('latency', 1), ...
%                           {delays1_in{i}}, ...
%                           {delays1_in{i+1}});
%         delays2_in{i+1}=xSignal(['delays2_in',num2str(i+1)]);
%         delays2{i} = xBlock(struct('source', 'Delay', 'name', ['Delay2',num2str(i)]), ...
%                           struct('latency', 1), ...
%                           {delays2_in{i}}, ...
%                           {delays2_in{i+1}}); 
%     end
%     
%     
%     % need to change to shift_mult_array
%     % slightly messed up here
%     multipliers = cell(1,m+1);
%     mult_out = cell(1,m+1);
%     for i = 1:2:m+1
%         mult_out{i} = xSignal(['mult_out',num2str(i)]);
%         multipliers{i} = xBlock(struct('source', 'Mult', 'name', ['mult',num2str(i)]), ...
%                                         struct('latency',2), ...
%                                         {delays2_in{idivide(i,int32(2))+1}, coeff_const{i}}, ...
%                                         {mult_out{i}}); 
%         mult_out{i+1} = xSignal(['mult_out',num2str(i+1)]);
%         multipliers{i+1} = xBlock(struct('source', 'Mult', 'name', ['mult',num2str(i+1)]), ...
%                                         struct('latency',2), ...
%                                         {delays1_in{idivide(i,int32(2))+1}, coeff_const{i+1}}, ...
%                                         {mult_out{i+1}}); 
%     end
%     
%     % take care of sync
%     sync_adder =xSignal('sync_adder');
%     sync_adder_out = xSignal('sync_adder_out');
%     sync_delay1 = xBlock(struct('source','Delay','name', 'sync_delay1'), ...
%                           struct('latency', 2), ...
%                           {sync}, ...
%                           {sync_adder});
% 
%     adder_out1 = xSignal('adder_out1');
%     adder_out2 = xSignal('adder_out2');
%     xlsub3_addertree1 = xBlock(struct('source', str2func('adder_tree_init_xblock'),'name', 'adder_tree1'), ...
%              {double(idivide(m,int32(2))+1), add_latency, 'Round  (unbiased: +/- Inf)', 'Saturate', 'Behavioral'}, ...
%              [{sync_adder},{mult_out{1:2:end}}], ...
%              {sync_adder_out,adder_out1});
%     xlsub3_addertree2 = xBlock(struct('source', str2func('adder_tree_init_xblock'),'name', 'adder_tree2'), ...
%              {double(idivide(m,int32(2))+1), add_latency, 'Round  (unbiased: +/- Inf)', 'Saturate', 'Behavioral'}, ...
%              [{sync_adder},{mult_out{2:2:end}}], ...
%              {{},adder_out2});
% 
% 
%     final_adder = xBlock(struct('source','AddSub','name','adder'), ...
%                             struct('mode', 'Addition', 'latency', add_latency, 'precision', 'Full', ...
%                                         'use_behavioral_HDL', 'off', 'hw_selection', 'Fabric'), ...
%                                         {adder_out1,adder_out2}, ...
%                                         {outport});
%     
%     % take care of sync 2
%      sync_delay2 = xBlock(struct('source','Delay','name', 'sync_delay2'), ...
%                       struct('latency', add_latency), ...
%                       {sync_adder_out}, ...
%                       {sync_out}); 
%                   
% elseif n_inputs > m
%     % assuming n_inputs > m
%     inports = cell(1,n_inputs);
%     for i = 1:n_inputs,
%         inports{i} = xInport(['inport',num2str(i)]);
%     end
%     sync = xInport('sync');
% 
% 
%     outports = cell(1,n_inputs);
%     for i=1+mod(oddeven+1,2):2:n_inputs,
%         outports{i} = xOutport(['outport',num2str(i)]);
%     end
%     sync_out = xOutport('sync_out');
% 
% 
%     if strcmp(polyphase,'off')
%         % take care of the delay cases
%         % need optimization (coefficient symmetric)
%         delayed_x_minus_p1 = cell(1,m);
%         xlsub3_delay = cell(1,m);
%         dmult_minus_p1 = cell(1,m);
%         xlsub3_dmult = cell(1,m);
%         for i=1:m-mod(oddeven+1,2)
%             delayed_x_minus_p1{i} = xSignal(['delay_x_m_minus_',num2str(i-1)]);
%             xlsub3_delay{i} = xBlock(struct('source', 'Delay', 'name', ['Delay',num2str(n_inputs-i+1)]), ...
%                               struct('latency', 1), ...
%                               {inports{n_inputs-i+1}}, ...
%                               {delayed_x_minus_p1{i}});
%             dmult_minus_p1{i} = cell(1,m);
%             xlsub3_dmult{i} = cell(1,m);
%             for j = i+(2-oddeven):2:m+1
%                 dmult_minus_p1{i}{j} = xSignal(['multiplied_m_minus_',num2str(i-1),'_',num2str(j)]);
%                 xlsub3_dmult{i}{j} = xBlock(struct('source', 'Mult', 'name', ['dmult_m_minus',num2str(i-1),'_',num2str(j)]), ...
%                                         struct('latency',2), ...
%                                         {delayed_x_minus_p1{i}, coeff_const{j}}, ...
%                                         {dmult_minus_p1{i}{j}});
%             end
%         end
% 
%         % take care of the non-delayed cases
%         % need optimization (coefficient symmetric)
%         % and there're redundants here
%         x_i_n = cell(1,n_inputs);
%         mult_i_n = cell(1,n_inputs);
%         xlsub3_mult = cell(1,n_inputs);
%         for i = 1:n_inputs-m
%             x_i_n{i} = inports{i};
%             mult_i_n{i} = cell(1,m+1);
%             xlsub3_mult{i} = cell(1,m+1);
%             sub_oddeven = mod(i+oddeven+1,2);
%             if sub_oddeven == 0 
%                 sub_oddeven = 2;
%             end
%             for j = sub_oddeven:2:m+1
%                 mult_i_n{i}{j} = xSignal(['multplied_x_i_n',num2str(i),'_',num2str(j)]);
%                 xlsub3_mult{i}{j} = xBlock(struct('source', 'Mult', 'name', ['mult',num2str(i),'_',num2str(j)]), ...
%                                         struct('latency',2), ...
%                                         {x_i_n{i}, coeff_const{j}}, ...
%                                         {mult_i_n{i}{j}});
%             end
%         end
%         % compensating the delayed cases
%         for i = n_inputs-m+1:n_inputs
%             x_i_n{i} = inports{i};
%             mult_i_n{i} = cell(1,(n_inputs-i)+1);
%             xlsub3_mult{i} = cell(1,(n_inputs-i)+1);
%             sub_oddeven = mod(i+oddeven+1,2);
%             if sub_oddeven == 0 
%                 sub_oddeven = 2;
%             end            
%             for j = sub_oddeven:2:(n_inputs-i)+1
%                 mult_i_n{i}{j} = xSignal(['multplied_x_i_n',num2str(i),'_',num2str(j)]);
%                 xlsub3_mult{i}{j} = xBlock(struct('source', 'Mult', 'name', ['mult',num2str(i),'_',num2str(j)]), ...
%                                         struct('latency',2), ...
%                                         {x_i_n{i}, coeff_const{j}}, ...
%                                         {mult_i_n{i}{j}});
%             end
%         end
%         
%         
% 
% 
%         % reorginize by making a matrix
%         mat = cell(n_inputs,1+m);
%         % the delay cases
%         % top triangle
%         first_row = 1;
%         if oddeven == 0
%             first_row = 2;
%         end
%         for i = first_row:2:m
%             for j = i+1:m+1
%                 mat{i,j} = dmult_minus_p1{j-i}{j};
%             end
%             % non-delay cases compensating the top triangle
%             for j = 1:i
%                 mat{i,j} = mult_i_n{i-j+1}{j};
%             end
%         end
%         % compensating the delay cases
%         % bottom triangle
%         new_start = m+1;
%         if mod(m,2) == oddeven
%             new_start = m+2;
%         end
%         for i = new_start :2: n_inputs
%             for j= 1:m+1
%                 mat{i,j} = mult_i_n{i-j+1}{j};
%             end
%         end
% 
% 
%         % take care of sync
%         sync_adder =xSignal('sync_adder');
%         sync_delay1 = xBlock(struct('source','Delay','name', 'sync_delay1'), ...
%                               struct('latency', 2), ...
%                               {sync}, ...
%                               {sync_adder});
% 
% 
%         % add up and output
%         xlsub3_addertree = cell(1,n_inputs);
%         check_sync_out = 0;
%         for i = 1+mod(oddeven+1,2):2:n_inputs
%             if check_sync_out ==0
%                 xlsub3_addertree{i} = xBlock(struct('source', str2func('adder_tree_init_xblock'),'name', ['adder_tree',num2str(i)]), ...
%                          {m+1, add_latency, 'Round  (unbiased: +/- Inf)', 'Saturate', 'Behavioral'}, ...
%                          {sync_adder,mat{i,:}}, ...
%                          {sync_out,outports{i}});
%                 check_sync_out = 1;
%             else
%                 xlsub3_addertree{i} = xBlock(struct('source', str2func('adder_tree_init_xblock'),'name', ['adder_tree',num2str(i)]), ...
%                          {m+1, add_latency, 'Round  (unbiased: +/- Inf)', 'Saturate', 'Behavioral'}, ...
%                          {sync_adder,mat{i,:}}, ...
%                          {{},outports{i}});
%             end
%         end
%     else
%     end
% end

